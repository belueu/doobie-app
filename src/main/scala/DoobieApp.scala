package io.belueu.app

import cats.effect.{ ExitCode, IO, IOApp }
import cats.implicits._
import doobie.implicits._
import doobie.postgres._
import doobie.postgres.implicits._
import doobie.util.transactor.Transactor
import doobie.util.update.Update
import doobie.util.{ Get, Put, Read, Write }
import doobie._

import java.util.UUID

object DoobieApp extends IOApp {

  case class Actor(
    id: Int,
    name: String
  )

  case class Movie(
    id: String,
    title: String,
    year: Int,
    actors: List[String],
    director: String
  )

  object Movie {

    //    implicit val listStringRead: Read[List[String]] = Read[String].map {
    //      case str => List(str)
    //    }
    //
    //    implicit val listStringWrite: Write[List[String]] = Write[String].contramap {
    //      case List(str) => str
    //    }

    implicit val movieRead: Read[Movie] = Read[(String, String, Int, List[String], String)].map {
      case (id, title, year, actors, director) => Movie(id, title, year, actors, director)
    }

    implicit val movieWrite: Write[Movie] = Write[(String, String, Int, List[String], String)].contramap {
      case Movie(id, title, year, actors, director) => (id, title, year, actors, director)
    }
  }

  implicit class Debugger[A](io: IO[A]) {
    def debug: IO[A] = io.map { actorName =>
      println(s"[${Thread.currentThread().getName}] $actorName")
      actorName
    }
  }

  val transactor: Transactor[IO] = Transactor.fromDriverManager[IO](
    "org.postgresql.Driver",
    "jdbc:postgresql://localhost:5432/myimdb",
    "docker",
    "docker"
  )

  def findAllActorNames: IO[Seq[String]] = {
    val query = sql"select name from actors".query[String]
    val action = query.to[Seq]
    action.transact(transactor)
  }

  def findActorById(id: Int): IO[Option[Actor]] = {
    val query = sql"select id, name from actors where id=$id".query[Actor]
    val action = query.option
    action.transact(transactor)
  }

  val actorNamesStream = sql"select name from actors".query[String].stream.compile.toList.transact(transactor)

  // High-level connection, High-level Prepared Statement
  def findActorByName(name: String): IO[Option[Actor]] = {
    val queryString = "select id, name from actors where name = ?"
    HC.stream[Actor](
      queryString,
      HPS.set(name),
      100
    ).compile.toList.map(_.headOption).transact(transactor)
  }

  // fragments
  def findActorsByInitialLetter(letter: String): IO[List[Actor]] = {
    val selectPart = fr"select id, name"
    val fromPart = fr"from actors"
    val wherePart = fr"where LEFT(name, 1) = $letter"
    val statement = selectPart ++ fromPart ++ wherePart
    statement.query[Actor].stream.compile.toList.transact(transactor)
  }

  // update
  def saveActor(id: Int, name: String): IO[Int] = {
    val query = sql"insert into actors (id, name) values ($id, $name)"
    query.update.run.transact(transactor)
  }

  def saveActor_v2(id: Int, name: String): IO[Int] = {
    val queryString = "insert into actors (id, name) values (?, ?)"
    Update[Actor](queryString).run(Actor(id, name)).transact(transactor)
  }

  // update/insert many
  def saveMultipleActors(actorNames: List[String]): IO[List[Actor]] = {
    val insertStatement = "insert into actors (name) values (?)"
    val updateAction = Update[String](insertStatement).updateManyWithGeneratedKeys[Actor]("id", "name")(actorNames)
    updateAction.compile.toList.transact(transactor)
  }

  // update with autogenerated id
  def saveWithAutoGenerated(name: String): IO[Int] = {
    sql"insert into actors (name) values ($name)".update.withUniqueGeneratedKeys[Int]("id")
      .transact(transactor)
  }

  // type classes
  class ActorName(val value: String) {
    override def toString: String = value
  }

  object ActorName {
    implicit val actorNameGet: Get[ActorName] = Get[String].map(string => new ActorName(string))
    implicit val actorNamePut: Put[ActorName] = Put[String].contramap(actorName => actorName.value)
  }

  def findAllActorNamesCustomClass: IO[List[ActorName]] = {
    sql"select name from actors".query[ActorName].to[List].transact(transactor)
  }

  // value types
  case class DirectorId(id: Int)
  case class DirectorFirstName(firstName: String)
  case class DirectorLastName(lastName: String)
  case class Director(directorId: DirectorId, directorFirstName: DirectorFirstName, directorLastName: DirectorLastName)

  object Director {
    implicit val directorRead: Read[Director] = Read[(Int, String, String)].map {
      case (id, firstName, lastName) => Director(DirectorId(id), DirectorFirstName(firstName), DirectorLastName(lastName))
    }

    implicit val directorWrite: Write[Director] = Write[(Int, String, String)].contramap {
      case Director(DirectorId(id), DirectorFirstName(firstName), DirectorLastName(lastName)) => (id, firstName, lastName)
    }
  }

  def findAllDirectorsCustomClass: IO[List[Director]] = {
    sql"select * from directors".query[Director].to[List].transact(transactor)
  }

  // write large queries
  def findMovieByTitle(title: String): IO[Option[Movie]] = {
    sql"""
          select m.id, m.title, m.year_of_production, array_agg(a.id || ' ' ||a.name) as actors, d.name || ' ' || d.last_name
          from movies m
          join movies_actors ma ON m.id = ma.movie_id
          join actors a ON ma.actor_id = a.id
          join directors d ON m.director_id = d.id
          where m.title = $title
          group by (m.id, m.title, m.year_of_production, d.name, d.last_name)
           """.stripMargin
      .query[Movie].option.transact(transactor)
  }

  def findMovieByTitle_v2(title: String): IO[Option[Movie]] = {
    def findMovieByTitle() =
      sql"select id, title, year_of_production, director_id from movies where title = $title"
        .query[(UUID, String, Int, Int)].option

    def findDirectorById(directorId: Int) =
      sql"select name, last_name from directors where id = $directorId"
        .query[(String, String)].option

    def findActorsByMovieId(movieId: UUID) =
      sql"""
            select a.name
            from actors a
            join movies_actors ma ON a.id = ma.actor_id
            where ma.movie_id = $movieId
         """
        .query[String]
        .to[List]
    val query = for {
      maybeMovie <- findMovieByTitle()
      maybeDirector <- maybeMovie match {
        case Some((_, _, _, directorId)) => findDirectorById(directorId)
        case None => Option.empty[(String, String)].pure[ConnectionIO]
      }
      actors <- maybeMovie match {
        case Some((movieId, _, _, _)) => findActorsByMovieId(movieId)
        case None => List.empty[String].pure[ConnectionIO]
      }
    } yield for {
      (id, title, year, _) <- maybeMovie
      (firsName, lastName) <- maybeDirector
    } yield Movie(id.toString, title, year, actors, s"$firsName $lastName")

    query.transact(transactor)
  }

  override def run(args: List[String]): IO[ExitCode] = {
    findMovieByTitle_v2("Zack Snyder's Justice League").debug.as(ExitCode.Success)
  }
}
